From 26744a15cfead946e7a4ca8b028fe4ea9bf96efe Mon Sep 17 00:00:00 2001
From: Ahmed ElArabawy <arabawy@google.com>
Date: Tue, 1 May 2018 09:11:13 -0700
Subject: [PATCH 05/32] WiFi: Extend SAR to support sap/scan-only modes

This commit is part of the feature of extending SAR Support in WiFi.
It adds support for both AP and Scan-Only modes.

This commit also adds some more general tests for SarManager class.

Bug: 65174506
Test: Run Wifi unit test suite
Test: ./frameworks/opt/net/wifi/tests/wifitests/runtests.sh

Change-Id: I04b61aaf69308600919c5f6e9ea61be130be9750
Signed-off-by: Ahmed ElArabawy <arabawy@google.com>
---
 .../com/android/server/wifi/SarManager.java   |  55 ++-
 .../server/wifi/ScanOnlyModeManager.java      |   7 +-
 .../android/server/wifi/SoftApManager.java    |  11 +-
 .../com/android/server/wifi/WifiInjector.java |   5 +-
 .../android/server/wifi/SarManagerTest.java   | 374 ++++++++++++++++++
 .../server/wifi/ScanOnlyModeManagerTest.java  |   5 +-
 .../server/wifi/SoftApManagerTest.java        |  25 +-
 7 files changed, 469 insertions(+), 13 deletions(-)

diff --git a/service/java/com/android/server/wifi/SarManager.java b/service/java/com/android/server/wifi/SarManager.java
index f157ac41e..d38eab981 100644
--- a/service/java/com/android/server/wifi/SarManager.java
+++ b/service/java/com/android/server/wifi/SarManager.java
@@ -42,6 +42,8 @@ import java.util.List;
  * This class provides the Support for SAR to control WiFi TX power limits.
  * It deals with the following:
  * - Tracking the STA state through calls from  the ClientModeManager.
+ * - Tracking the SAP state through calls from SoftApManager
+ * - Tracking the Scan-Only state through ScanOnlyModeManager
  * - Tracking the state of the Cellular calls or data.
  * - Tracking the sensor indicating proximity to user head/hand/body.
  * - It constructs the sar info and send it towards the HAL
@@ -181,6 +183,58 @@ public class SarManager {
         }
     }
 
+    /**
+     * Update Wifi SoftAP State
+     */
+    public void setSapWifiState(int state) {
+        boolean newIsEnabled;
+        /* No action is taken if SAR is not enabled */
+        if (!mEnableSarTxPowerLimit) {
+            return;
+        }
+
+        if (state == WifiManager.WIFI_AP_STATE_DISABLED) {
+            newIsEnabled = false;
+        } else if (state == WifiManager.WIFI_AP_STATE_ENABLED) {
+            newIsEnabled = true;
+        } else {
+            /* No change so exiting with no action */
+            return;
+        }
+
+        /* Report change to HAL if needed */
+        if (mSarInfo.mIsWifiSapEnabled != newIsEnabled) {
+            mSarInfo.mIsWifiSapEnabled = newIsEnabled;
+            updateSarScenario();
+        }
+    }
+
+    /**
+     * Update Wifi ScanOnly State
+     */
+    public void setScanOnlyWifiState(int state) {
+        boolean newIsEnabled;
+        /* No action is taken if SAR is not enabled */
+        if (!mEnableSarTxPowerLimit) {
+            return;
+        }
+
+        if (state == WifiManager.WIFI_STATE_DISABLED) {
+            newIsEnabled = false;
+        } else if (state == WifiManager.WIFI_STATE_ENABLED) {
+            newIsEnabled = true;
+        } else {
+            /* No change so exiting with no action */
+            return;
+        }
+
+        /* Report change to HAL if needed */
+        if (mSarInfo.mIsWifiScanOnlyEnabled != newIsEnabled) {
+            mSarInfo.mIsWifiScanOnlyEnabled = newIsEnabled;
+            updateSarScenario();
+        }
+    }
+
     /**
      * Report Cell state event
      */
@@ -238,7 +292,6 @@ public class SarManager {
      * Enable/disable verbose logging.
      */
     public void enableVerboseLogging(int verbose) {
-        Log.d(TAG, "Inside enableVerboseLogging: " + verbose);
         if (verbose > 0) {
             mVerboseLoggingEnabled = true;
         } else {
diff --git a/service/java/com/android/server/wifi/ScanOnlyModeManager.java b/service/java/com/android/server/wifi/ScanOnlyModeManager.java
index 346d2ca67..991657929 100644
--- a/service/java/com/android/server/wifi/ScanOnlyModeManager.java
+++ b/service/java/com/android/server/wifi/ScanOnlyModeManager.java
@@ -48,6 +48,7 @@ public class ScanOnlyModeManager implements ActiveModeManager {
     private final Listener mListener;
     private final ScanRequestProxy mScanRequestProxy;
     private final WakeupController mWakeupController;
+    private final SarManager mSarManager;
 
     private String mClientInterfaceName;
     private boolean mIfaceIsUp = false;
@@ -58,13 +59,15 @@ public class ScanOnlyModeManager implements ActiveModeManager {
                         @NonNull WifiNative wifiNative, @NonNull Listener listener,
                         @NonNull WifiMetrics wifiMetrics,
                         @NonNull ScanRequestProxy scanRequestProxy,
-                        @NonNull WakeupController wakeupController) {
+                        @NonNull WakeupController wakeupController,
+                        @NonNull SarManager sarManager) {
         mContext = context;
         mWifiNative = wifiNative;
         mListener = listener;
         mWifiMetrics = wifiMetrics;
         mScanRequestProxy = scanRequestProxy;
         mWakeupController = wakeupController;
+        mSarManager = sarManager;
         mStateMachine = new ScanOnlyModeStateMachine(looper);
     }
 
@@ -242,6 +245,7 @@ public class ScanOnlyModeManager implements ActiveModeManager {
 
                 mIfaceIsUp = false;
                 onUpChanged(mWifiNative.isInterfaceUp(mClientInterfaceName));
+                mSarManager.setScanOnlyWifiState(WifiManager.WIFI_STATE_ENABLED);
             }
 
             @Override
@@ -281,6 +285,7 @@ public class ScanOnlyModeManager implements ActiveModeManager {
                     mClientInterfaceName = null;
                 }
                 updateWifiState(WifiManager.WIFI_STATE_DISABLED);
+                mSarManager.setScanOnlyWifiState(WifiManager.WIFI_STATE_DISABLED);
 
                 // once we leave started, nothing else to do...  stop the state machine
                 mStateMachine.quitNow();
diff --git a/service/java/com/android/server/wifi/SoftApManager.java b/service/java/com/android/server/wifi/SoftApManager.java
index 6c52918a5..1afe9ed9d 100644
--- a/service/java/com/android/server/wifi/SoftApManager.java
+++ b/service/java/com/android/server/wifi/SoftApManager.java
@@ -93,6 +93,8 @@ public class SoftApManager implements ActiveModeManager {
     private int mNumAssociatedStations = 0;
     private boolean mTimeoutEnabled = false;
 
+    private final SarManager mSarManager;
+
     /**
      * Listener for soft AP events.
      */
@@ -118,7 +120,8 @@ public class SoftApManager implements ActiveModeManager {
                          @NonNull WifiManager.SoftApCallback callback,
                          @NonNull WifiApConfigStore wifiApConfigStore,
                          @NonNull SoftApModeConfiguration apConfig,
-                         @NonNull WifiMetrics wifiMetrics) {
+                         @NonNull WifiMetrics wifiMetrics,
+                         @NonNull SarManager sarManager) {
         mContext = context;
         mFrameworkFacade = framework;
         mWifiNative = wifiNative;
@@ -133,6 +136,7 @@ public class SoftApManager implements ActiveModeManager {
             mApConfig = config;
         }
         mWifiMetrics = wifiMetrics;
+        mSarManager = sarManager;
         mStateMachine = new SoftApStateMachine(looper);
     }
 
@@ -491,6 +495,9 @@ public class SoftApManager implements ActiveModeManager {
                 if (mSettingObserver != null) {
                     mSettingObserver.register();
                 }
+                
+                mSarManager.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+
                 Log.d(TAG, "Resetting num stations on start");
                 mNumAssociatedStations = 0;
                 scheduleTimeoutMessage();
@@ -512,6 +519,8 @@ public class SoftApManager implements ActiveModeManager {
                 mWifiMetrics.addSoftApUpChangedEvent(false, mMode);
                 updateApState(WifiManager.WIFI_AP_STATE_DISABLED,
                         WifiManager.WIFI_AP_STATE_DISABLING, 0);
+
+                mSarManager.setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
                 mApInterfaceName = null;
                 mIfaceIsUp = false;
                 mStateMachine.quitNow();
diff --git a/service/java/com/android/server/wifi/WifiInjector.java b/service/java/com/android/server/wifi/WifiInjector.java
index 5a4fe570b..199548090 100644
--- a/service/java/com/android/server/wifi/WifiInjector.java
+++ b/service/java/com/android/server/wifi/WifiInjector.java
@@ -465,7 +465,7 @@ public class WifiInjector {
                                            @NonNull SoftApModeConfiguration config) {
         return new SoftApManager(mContext, mWifiStateMachineHandlerThread.getLooper(),
                 mFrameworkFacade, mWifiNative, mCountryCode.getCountryCode(), callback,
-                mWifiApConfigStore, config, mWifiMetrics);
+                mWifiApConfigStore, config, mWifiMetrics, mSarManager);
     }
 
     /**
@@ -477,7 +477,8 @@ public class WifiInjector {
     public ScanOnlyModeManager makeScanOnlyModeManager(
             @NonNull ScanOnlyModeManager.Listener listener) {
         return new ScanOnlyModeManager(mContext, mWifiStateMachineHandlerThread.getLooper(),
-                mWifiNative, listener, mWifiMetrics, mScanRequestProxy, mWakeupController);
+                mWifiNative, listener, mWifiMetrics, mScanRequestProxy, mWakeupController,
+                mSarManager);
     }
 
     /**
diff --git a/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java b/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
index 69878cdcf..369dcba33 100644
--- a/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/SarManagerTest.java
@@ -374,6 +374,10 @@ public class SarManagerTest {
         /* Device should set tx power scenario to NORMAL again */
         inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
         assertFalse(mSarInfo.mIsVoiceCall);
+
+        /* Disable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
     }
 
     /**
@@ -397,6 +401,134 @@ public class SarManagerTest {
         inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
     }
 
+    /**
+     * Test that for devices supporting SAR the following scenario:
+     * - Wifi enabled
+     * - A call starts
+     * - Wifi disabled
+     * - Call ends
+     * - Wifi back on
+     */
+    @Test
+    public void testSarMgr_enabledSar_wifiOn_offHook_wifiOff_onHook() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        /* Now device should set tx power scenario to NORMAL */
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+
+        /* Set phone state to OFFHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_OFFHOOK, "");
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertTrue(mSarInfo.mIsVoiceCall);
+
+        /* Disable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Set state back to ONHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_IDLE, "");
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi State again */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+    }
+
+    /**
+     * Test that for devices supporting SAR, Wifi disabled, a call starts, a call ends, Wifi
+     * enabled.
+     */
+    @Test
+    public void testSarMgr_enabledSar_wifiOff_offHook_onHook_wifiOn() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Set phone state to OFFHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_OFFHOOK, "");
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Set state back to ONHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_IDLE, "");
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+    }
+
+    /**
+     * Test that for devices supporting SAR, Wifi disabled, a call starts, wifi on, wifi off,
+     * call ends.
+     */
+    @Test
+    public void testSarMgr_enabledSar_offHook_wifiOnOff_onHook() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Set phone state to OFFHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_OFFHOOK, "");
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+        assertNotNull(mSarInfo);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertTrue(mSarInfo.mIsVoiceCall);
+
+        /* Disable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Set state back to ONHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_IDLE, "");
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+    }
+
+    /**
+     * Test the error case for for devices supporting SAR, Wifi enabled, a call starts,
+     * call ends. With all of these cases, the call to set Tx power scenario fails.
+     */
+    @Test
+    public void testSarMgr_enabledSar_error_wifiOn_offOnHook() throws Exception {
+        createSarManager(true, false);
+
+        when(mWifiNative.selectTxPowerScenario(any(SarInfo.class))).thenReturn(false);
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+        assertNotNull(mSarInfo);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+
+        /* Set phone state to OFFHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_OFFHOOK, "");
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertTrue(mSarInfo.mIsVoiceCall);
+
+        /* Set state back to ONHOOK */
+        mPhoneStateListener.onCallStateChanged(CALL_STATE_IDLE, "");
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+    }
+
     /**
      * Test that for a device that has SAR enabled, with sar sensor enabled,
      * wifi enabled, Then Tx power scenarios follow events from sensor for body/hand/head/none
@@ -654,4 +786,246 @@ public class SarManagerTest {
         assertEquals(SarInfo.SAR_SENSOR_NEAR_HEAD, mSarInfo.mSensorState);
         assertFalse(mSarInfo.mIsVoiceCall);
     }
+
+    /**
+     * Test that Start of SoftAP for a device that does not have SAR enabled does not result in
+     * setting the Tx power scenario
+     */
+    @Test
+    public void testSarMgr_disabledTxPowerScenario_sapOn() throws Exception {
+        createSarManager(false, false);
+
+        /* Enable WiFi SoftAP State */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+
+        verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+    }
+
+    /**
+     * Test that Start of SoftAP for a device that has SAR enabled, SAR sensor disabled.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_sapOn() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable WiFi SoftAP State */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+    }
+
+    /**
+     * Test that for a device that has SAR enabled, SAR sensor enabled, near head, and when
+     * wifi sta is enabled, turning on sap then turning it off.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_staOn_sapOnOff() throws Exception {
+        createSarManager(true, true);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Sensor event */
+        sendSensorEvent(SAR_SENSOR_EVENT_HEAD);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi Client State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertEquals(SarInfo.SAR_SENSOR_NEAR_HEAD, mSarInfo.mSensorState);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+
+        /* Enable WiFi SoftAP State */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertEquals(SarInfo.SAR_SENSOR_NEAR_HEAD, mSarInfo.mSensorState);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+
+        /* Disable Wifi SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertEquals(SarInfo.SAR_SENSOR_NEAR_HEAD, mSarInfo.mSensorState);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+    }
+
+    /**
+     * Test that for a device that has SAR enabled, SAR sensor enabled, Near body, and when
+     * disabling wifi softAP while Wifi Sta is also disabled, no update to the HAL for Tx
+     * power scenario is issued.
+     * Then, when wifi client is enabled, the Tx Power scenario is set.
+     * This is to verify that no call to update tx power when all wifi modes are disabled.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_sapOnOff_staOffOn() throws Exception {
+        createSarManager(true, true);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Sensor event */
+        sendSensorEvent(SAR_SENSOR_EVENT_BODY);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi softAP State */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertEquals(SarInfo.SAR_SENSOR_NEAR_BODY, mSarInfo.mSensorState);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+
+        /* Disable Wifi SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable WiFi Clinet State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertEquals(SarInfo.SAR_SENSOR_NEAR_BODY, mSarInfo.mSensorState);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+    }
+
+    /**
+     * Test that for a device that has SAR enabled, when scan-only state is enabled with both SoftAP
+     * and Client states disabled, the SarInfo is reported with proper values.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_staOff_sapOff_scanOnlyOn() throws Exception {
+        createSarManager(true, false);
+
+        /* Enable Wifi ScanOnly State */
+        mSarMgr.setScanOnlyWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertTrue(mSarInfo.mIsWifiScanOnlyEnabled);
+    }
+
+    /**
+     * Test that for a device that has SAR enabled, when scan-only state is enabled, and then
+     * client state is enabled, no additional setting of Tx power scenario is initiated
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_staOn_sapOff_scanOnlyOn() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable Wifi ScanOnly State */
+        mSarMgr.setScanOnlyWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertTrue(mSarInfo.mIsWifiScanOnlyEnabled);
+
+        /* Now enable Client state */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+    }
+
+    /**
+     * Test the success case for for devices supporting SAR, with no SAR sensor support,
+     * Wifi enabled, SoftAP enabled, wifi disabled, scan-only enabled, SoftAP disabled.
+     *
+     * SarManager should report these changes as they occur(only when changes occur to
+     * inputs affecting the SAR scenario).
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_wifi_sap_scanOnly() throws Exception {
+        createSarManager(true, false);
+
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+
+        /* Enable SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+
+        /* Disable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Enable ScanOnly state */
+        mSarMgr.setScanOnlyWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative, never()).selectTxPowerScenario(any(SarInfo.class));
+
+        /* Disable SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertTrue(mSarInfo.mIsWifiScanOnlyEnabled);
+    }
+
+    /**
+     * Test the error case for devices supporting SAR, with no SAR sensor support,
+     * Wifi enabled, SoftAP enabled, wifi disabled, scan-only enabled, SoftAP disabled
+     * Throughout this test case, calls to the hal return with error.
+     */
+    @Test
+    public void testSarMgr_enabledTxPowerScenario_error_wifi_sap_scanOnly() throws Exception {
+        createSarManager(true, false);
+
+        when(mWifiNative.selectTxPowerScenario(any(SarInfo.class))).thenReturn(false);
+        InOrder inOrder = inOrder(mWifiNative);
+
+        /* Enable WiFi State */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        captureSarInfo(mWifiNative);
+
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+
+        /* Enable SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+
+        /* Disable WiFi State, reporting should still happen */
+        mSarMgr.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+        assertFalse(mSarInfo.mIsWifiScanOnlyEnabled);
+        assertFalse(mSarInfo.mIsWifiClientEnabled);
+
+        /* Enable ScanOnly state */
+        mSarMgr.setScanOnlyWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertTrue(mSarInfo.mIsWifiSapEnabled);
+        assertTrue(mSarInfo.mIsWifiScanOnlyEnabled);
+        assertFalse(mSarInfo.mIsWifiClientEnabled);
+
+        /* Disable SoftAP state */
+        mSarMgr.setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
+        inOrder.verify(mWifiNative).selectTxPowerScenario(eq(mSarInfo));
+        assertFalse(mSarInfo.mIsVoiceCall);
+        assertFalse(mSarInfo.mIsWifiSapEnabled);
+        assertTrue(mSarInfo.mIsWifiScanOnlyEnabled);
+        assertFalse(mSarInfo.mIsWifiClientEnabled);
+    }
 }
diff --git a/tests/wifitests/src/com/android/server/wifi/ScanOnlyModeManagerTest.java b/tests/wifitests/src/com/android/server/wifi/ScanOnlyModeManagerTest.java
index 41362eec6..8c2444592 100644
--- a/tests/wifitests/src/com/android/server/wifi/ScanOnlyModeManagerTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/ScanOnlyModeManagerTest.java
@@ -71,6 +71,7 @@ public class ScanOnlyModeManagerTest {
     @Mock WifiMonitor mWifiMonitor;
     @Mock ScanRequestProxy mScanRequestProxy;
     @Mock WakeupController mWakeupController;
+    @Mock SarManager mSarManager;
 
     final ArgumentCaptor<WifiNative.InterfaceCallback> mInterfaceCallbackCaptor =
             ArgumentCaptor.forClass(WifiNative.InterfaceCallback.class);
@@ -86,7 +87,7 @@ public class ScanOnlyModeManagerTest {
 
     private ScanOnlyModeManager createScanOnlyModeManager() {
         return new ScanOnlyModeManager(mContext, mLooper.getLooper(), mWifiNative, mListener,
-                mWifiMetrics, mScanRequestProxy, mWakeupController);
+                mWifiMetrics, mScanRequestProxy, mWakeupController, mSarManager);
     }
 
     private void startScanOnlyModeAndVerifyEnabled() throws Exception {
@@ -112,6 +113,7 @@ public class ScanOnlyModeManagerTest {
         checkWifiStateChangeListenerUpdate(WIFI_STATE_ENABLED);
         verify(mScanRequestProxy, atLeastOnce()).clearScanResults();
         verify(mScanRequestProxy, atLeastOnce()).enableScanningForHiddenNetworks(false);
+        verify(mSarManager).setScanOnlyWifiState(eq(WIFI_STATE_ENABLED));
     }
 
     private void checkWifiScanStateChangedBroadcast(Intent intent, int expectedCurrentState) {
@@ -170,6 +172,7 @@ public class ScanOnlyModeManagerTest {
         mLooper.dispatchAll();
         verify(mWifiNative).teardownInterface(TEST_INTERFACE_NAME);
         verify(mContext, never()).sendStickyBroadcastAsUser(any(), eq(UserHandle.ALL));
+        verify(mSarManager).setScanOnlyWifiState(eq(WIFI_STATE_DISABLED));
         verifyNoMoreInteractions(mListener);
     }
 
diff --git a/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java b/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
index 0b937849d..6a2c21242 100644
--- a/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/SoftApManagerTest.java
@@ -90,6 +90,7 @@ public class SoftApManagerTest {
     @Mock FrameworkFacade mFrameworkFacade;
     @Mock WifiApConfigStore mWifiApConfigStore;
     @Mock WifiMetrics mWifiMetrics;
+    @Mock SarManager mSarManager;
     final ArgumentCaptor<WifiNative.InterfaceCallback> mWifiNativeInterfaceCallbackCaptor =
             ArgumentCaptor.forClass(WifiNative.InterfaceCallback.class);
     final ArgumentCaptor<WifiNative.SoftApListener> mSoftApListenerCaptor =
@@ -133,7 +134,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            config,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
 
         return newSoftApManager;
@@ -205,7 +207,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            nullApConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
         newSoftApManager.start();
         mLooper.dispatchAll();
@@ -247,7 +250,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            nullApConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
         newSoftApManager.start();
         mLooper.dispatchAll();
@@ -288,7 +292,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            nullApConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
         newSoftApManager.start();
         mLooper.dispatchAll();
@@ -329,7 +334,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            softApConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
         newSoftApManager.start();
         mLooper.dispatchAll();
@@ -371,7 +377,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            softApConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
         mLooper.dispatchAll();
         newSoftApManager.start();
         mLooper.dispatchAll();
@@ -408,7 +415,8 @@ public class SoftApManagerTest {
                                                            mCallback,
                                                            mWifiApConfigStore,
                                                            softApModeConfig,
-                                                           mWifiMetrics);
+                                                           mWifiMetrics,
+                                                           mSarManager);
 
         mLooper.dispatchAll();
         newSoftApManager.start();
@@ -429,6 +437,7 @@ public class SoftApManagerTest {
         mLooper.dispatchAll();
         /* Verify no state changes. */
         verify(mCallback, never()).onStateChanged(anyInt(), anyInt());
+        verify(mSarManager, never()).setSapWifiState(anyInt());
         verify(mContext, never()).sendStickyBroadcastAsUser(any(), any());
         verify(mWifiNative, never()).teardownInterface(anyString());
     }
@@ -459,6 +468,7 @@ public class SoftApManagerTest {
                 softApModeConfig.getTargetMode());
 
         order.verify(mCallback).onStateChanged(WifiManager.WIFI_AP_STATE_DISABLED, 0);
+        verify(mSarManager).setSapWifiState(WifiManager.WIFI_AP_STATE_DISABLED);
         order.verify(mContext).sendStickyBroadcastAsUser(intentCaptor.capture(),
                 eq(UserHandle.ALL));
         checkApStateChangedBroadcast(intentCaptor.getValue(), WIFI_AP_STATE_DISABLED,
@@ -938,6 +948,7 @@ public class SoftApManagerTest {
         mLooper.dispatchAll();
         order.verify(mCallback).onStateChanged(WifiManager.WIFI_AP_STATE_ENABLED, 0);
         order.verify(mCallback).onNumClientsChanged(0);
+        verify(mSarManager).setSapWifiState(WifiManager.WIFI_AP_STATE_ENABLED);
         verify(mContext, times(2)).sendStickyBroadcastAsUser(intentCaptor.capture(),
                                                              eq(UserHandle.ALL));
         List<Intent> capturedIntents = intentCaptor.getAllValues();
-- 
2.17.1

