From e3b789798d09a9058ab8b4c029b71ffc465256b0 Mon Sep 17 00:00:00 2001
From: Hall Liu <hallliu@google.com>
Date: Mon, 25 Jun 2018 19:45:53 -0700
Subject: [PATCH 07/39] Fix thread leak from RttTextHandler

The reader thread for reading from in-call wasn't shutting down properly
before. This led to interleaving of messages if RTT went on, then off
again, then on. Add an interrupt call upon teardown so that the thread
can properly stop.

Change-Id: I1f0b4afe14ad218ca58e2feb3d8861f5d76ebe8e
Fixes: 110570772
Test: manual (follow repro steps in bug, but type really fast),treehugger
---
 .../telephony/imsphone/ImsPhoneConnection.java   |  3 +++
 .../telephony/imsphone/ImsRttTextHandler.java    | 16 +++++++++-------
 2 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index d63b9c254..0ee302ac1 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -458,6 +458,9 @@ public class ImsPhoneConnection extends Connection implements
                 Rlog.d(LOG_TAG, "onDisconnect: no parent");
             }
             synchronized (this) {
+                if (mRttTextHandler != null) {
+                    mRttTextHandler.tearDown();
+                }
                 if (mImsCall != null) mImsCall.close();
                 mImsCall = null;
             }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
index 3f9e8a8b7..eff249979 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
@@ -25,6 +25,7 @@ import android.telephony.Rlog;
 import com.android.internal.annotations.VisibleForTesting;
 
 import java.io.IOException;
+import java.nio.channels.ClosedByInterruptException;
 import java.util.concurrent.CountDownLatch;
 
 public class ImsRttTextHandler extends Handler {
@@ -79,17 +80,16 @@ public class ImsRttTextHandler extends Handler {
                 String charsReceived;
                 try {
                     charsReceived = mReaderThreadRttTextStream.read();
+                } catch (ClosedByInterruptException e) {
+                    Rlog.i(LOG_TAG, "RttReaderThread - Thread interrupted. Finishing.");
+                    break;
                 } catch (IOException e) {
                     Rlog.e(LOG_TAG, "RttReaderThread - IOException encountered " +
-                            "reading from in-call: %s", e);
+                            "reading from in-call: ", e);
                     obtainMessage(TEARDOWN).sendToTarget();
                     break;
                 }
                 if (charsReceived == null) {
-                    if (Thread.currentThread().isInterrupted()) {
-                        Rlog.i(LOG_TAG, "RttReaderThread - Thread interrupted. Finishing.");
-                        break;
-                    }
                     Rlog.e(LOG_TAG, "RttReaderThread - Stream closed unexpectedly. Attempt to " +
                             "reinitialize.");
                     obtainMessage(TEARDOWN).sendToTarget();
@@ -145,7 +145,7 @@ public class ImsRttTextHandler extends Handler {
                 int numCodepointsBuffered = mBufferedTextToNetwork
                         .codePointCount(0, mBufferedTextToNetwork.length());
                 if (numCodepointsBuffered >= MAX_BUFFERED_CHARACTER_COUNT) {
-                    sendMessageAtFrontOfQueue(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
+                    sendMessage(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
                 } else {
                     sendEmptyMessageDelayed(
                             ATTEMPT_SEND_TO_NETWORK, MAX_BUFFERING_DELAY_MILLIS);
@@ -175,12 +175,13 @@ public class ImsRttTextHandler extends Handler {
             case EXPIRE_SENT_CODEPOINT_COUNT:
                 mCodepointsAvailableForTransmission += msg.arg1;
                 if (mCodepointsAvailableForTransmission > 0) {
-                    sendMessageAtFrontOfQueue(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
+                    sendMessage(obtainMessage(ATTEMPT_SEND_TO_NETWORK));
                 }
                 break;
             case TEARDOWN:
                 try {
                     if (mReaderThread != null) {
+                        mReaderThread.interrupt();
                         mReaderThread.join(1000);
                     }
                 } catch (InterruptedException e) {
@@ -202,6 +203,7 @@ public class ImsRttTextHandler extends Handler {
     }
 
     public void initialize(Connection.RttTextStream rttTextStream) {
+        Rlog.i(LOG_TAG, "Initializing: " + this);
         obtainMessage(INITIALIZE, rttTextStream).sendToTarget();
     }
 
-- 
2.17.1

