From 6016bdc182c4842a3c82e331fa4fd693f402328c Mon Sep 17 00:00:00 2001
From: Hall Liu <hallliu@google.com>
Date: Wed, 25 Jul 2018 18:46:27 -0700
Subject: [PATCH 11/39] Add support for auto redialing 911

When we get a SIP 380 from the modem when trying to make an emergency
call in airplane mode with wifi calling turned on, automatically retry
(gated on a carrier config) by turning off airplane mode then redialing.

Bug: 111235453
Test: manual (modify IMS stack locally to always return the 380 error
when dialing in airplane mode)

Change-Id: Icde9d792c3f1561d6e0fc6863c278e7bb89ddb78
Merged-In: I37b6ac67c1459bf4e0d849333744bd2018970c97
---
 .../internal/telephony/Connection.java        |   8 ++
 .../internal/telephony/imsphone/ImsPhone.java |   5 +
 .../imsphone/ImsPhoneCallTracker.java         | 101 ++++++++++++++----
 3 files changed, 93 insertions(+), 21 deletions(-)

diff --git a/src/java/com/android/internal/telephony/Connection.java b/src/java/com/android/internal/telephony/Connection.java
index b37ad04e9..62fc5b025 100644
--- a/src/java/com/android/internal/telephony/Connection.java
+++ b/src/java/com/android/internal/telephony/Connection.java
@@ -107,6 +107,7 @@ public abstract class Connection {
         public void onDisconnect(int cause);
         public void onRttInitiated();
         public void onRttTerminated();
+        public void onOriginalConnectionReplaced(Connection newConnection);
     }
 
     /**
@@ -152,6 +153,8 @@ public abstract class Connection {
         public void onRttInitiated() {}
         @Override
         public void onRttTerminated() {}
+        @Override
+        public void onOriginalConnectionReplaced(Connection newConnection) {}
     }
 
     public static final int AUDIO_QUALITY_STANDARD = 1;
@@ -1022,6 +1025,11 @@ public abstract class Connection {
         }
     }
 
+    public void onOriginalConnectionReplaced(Connection newConnection) {
+        for (Listener l : mListeners) {
+            l.onOriginalConnectionReplaced(newConnection);
+        }
+    }
     /**
      * Notifies the connection that there was a failure while handing over to WIFI.
      */
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index 963a2e3d9..333369795 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -650,6 +650,11 @@ public class ImsPhone extends ImsPhoneBase {
         mDefaultPhone.notifyForVideoCapabilityChanged(isVideoCapable);
     }
 
+    @Override
+    public void setRadioPower(boolean on) {
+        mDefaultPhone.setRadioPower(on);
+    }
+
     @Override
     public Connection dial(String dialString, DialArgs dialArgs) throws CallStateException {
         return dialInternal(dialString, dialArgs, null);
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 4c858cc32..7a5275c26 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -90,6 +90,7 @@ import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.Connection;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneInternalInterface;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.dataconnection.DataEnabledSettings;
@@ -277,11 +278,15 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private static final int EVENT_CHECK_FOR_WIFI_HANDOVER = 25;
     private static final int EVENT_ON_FEATURE_CAPABILITY_CHANGED = 26;
     private static final int EVENT_SUPP_SERVICE_INDICATION = 27;
+    private static final int EVENT_REDIAL_WIFI_E911_CALL = 28;
+    private static final int EVENT_REDIAL_WIFI_E911_TIMEOUT = 29;
 
     private static final int TIMEOUT_HANGUP_PENDINGMO = 500;
 
     private static final int HANDOVER_TO_WIFI_TIMEOUT_MS = 60000; // ms
 
+    private static final int TIMEOUT_REDIAL_WIFI_E911_MS = 10000;
+
     //***** Instance Variables
     private ArrayList<ImsPhoneConnection> mConnections = new ArrayList<ImsPhoneConnection>();
     private RegistrantList mVoiceCallEndedRegistrants = new RegistrantList();
@@ -336,7 +341,10 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private boolean mIgnoreDataEnabledChangedForVideoCalls = false;
     private boolean mIsViLteDataMetered = false;
     private boolean mAlwaysPlayRemoteHoldTone = false;
+    private boolean mAutoRetryFailedWifiEmergencyCall = false;
 
+    private String mLastDialString = null;
+    private PhoneInternalInterface.DialArgs mLastDialArgs = null;
     /**
      * Listeners to changes in the phone state.  Intended for use by other interested IMS components
      * without the need to register a full blown {@link android.telephony.PhoneStateListener}.
@@ -961,6 +969,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
             }
 
+            mLastDialString = dialString;
+            mLastDialArgs = dialArgs;
             mPendingMO = new ImsPhoneConnection(mPhone,
                     checkForTestEmergencyNumber(dialString), this, mForegroundCall,
                     isEmergencyNumber);
@@ -1096,6 +1106,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
         mAlwaysPlayRemoteHoldTone = carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_ALWAYS_PLAY_REMOTE_HOLD_TONE_BOOL);
+        mAutoRetryFailedWifiEmergencyCall = carrierConfig.getBoolean(
+                CarrierConfigManager.KEY_AUTO_RETRY_FAILED_WIFI_EMERGENCY_CALL);
 
         String[] mappings = carrierConfig
                 .getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
@@ -2215,26 +2227,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                     mPhone.initiateSilentRedial();
                     return;
                 } else {
-                    mPendingMO = null;
-                    ImsPhoneConnection conn = findConnection(imsCall);
-                    Call.State callState;
-                    if (conn != null) {
-                        callState = conn.getState();
-                    } else {
-                        // Need to fall back in case connection is null; it shouldn't be, but a sane
-                        // fallback is to assume we're dialing.  This state is only used to
-                        // determine which disconnect string to show in the case of a low battery
-                        // disconnect.
-                        callState = Call.State.DIALING;
-                    }
-                    int cause = getDisconnectCauseFromReasonInfo(reasonInfo, callState);
-
-                    if(conn != null) {
-                        conn.setPreciseDisconnectCause(
-                                getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
-                    }
-
-                    processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+                    sendCallStartFailedDisconnect(imsCall, reasonInfo);
                 }
                 mMetrics.writeOnImsCallStartFailed(mPhone.getPhoneId(), imsCall.getCallSession(),
                         reasonInfo);
@@ -2317,7 +2310,21 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 conn.setPreciseDisconnectCause(getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
             }
 
-            processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+            if (reasonInfo.getCode() == ImsReasonInfo.CODE_SIP_ALTERNATE_EMERGENCY_CALL
+                    && mAutoRetryFailedWifiEmergencyCall) {
+                Pair<ImsCall, ImsReasonInfo> callInfo = new Pair<>(imsCall, reasonInfo);
+                mPhone.getDefaultPhone().getServiceStateTracker().registerForNetworkAttached(
+                        ImsPhoneCallTracker.this, EVENT_REDIAL_WIFI_E911_CALL, callInfo);
+                sendMessageDelayed(obtainMessage(EVENT_REDIAL_WIFI_E911_TIMEOUT, callInfo),
+                        TIMEOUT_REDIAL_WIFI_E911_MS);
+                final ConnectivityManager mgr = (ConnectivityManager) mPhone.getContext()
+                        .getSystemService(Context.CONNECTIVITY_SERVICE);
+                mgr.setAirplaneMode(false);
+                return;
+            } else {
+                processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+            }
+
             if (mForegroundCall.getState() != ImsPhoneCall.State.ACTIVE) {
                 if (mRingingCall.getState().isRinging()) {
                     // Drop pending MO. We should address incoming call first
@@ -2953,6 +2960,29 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
     };
 
+    public void sendCallStartFailedDisconnect(ImsCall imsCall, ImsReasonInfo reasonInfo) {
+        mPendingMO = null;
+        ImsPhoneConnection conn = findConnection(imsCall);
+        Call.State callState;
+        if (conn != null) {
+            callState = conn.getState();
+        } else {
+            // Need to fall back in case connection is null; it shouldn't be, but a sane
+            // fallback is to assume we're dialing.  This state is only used to
+            // determine which disconnect string to show in the case of a low battery
+            // disconnect.
+            callState = Call.State.DIALING;
+        }
+        int cause = getDisconnectCauseFromReasonInfo(reasonInfo, callState);
+
+        if (conn != null) {
+            conn.setPreciseDisconnectCause(
+                    getPreciseDisconnectCauseFromReasonInfo(reasonInfo));
+        }
+
+        processCallStateChange(imsCall, ImsPhoneCall.State.DISCONNECTED, cause);
+    }
+
     public ImsUtInterface getUtInterface() throws ImsException {
         if (mImsManager == null) {
             throw getImsManagerIsNullException();
@@ -3124,6 +3154,35 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
                 break;
             }
+            case EVENT_REDIAL_WIFI_E911_CALL: {
+                Pair<ImsCall, ImsReasonInfo> callInfo =
+                        (Pair<ImsCall, ImsReasonInfo>) ((AsyncResult) msg.obj).userObj;
+                removeMessages(EVENT_REDIAL_WIFI_E911_TIMEOUT);
+                mPhone.getDefaultPhone().getServiceStateTracker()
+                        .unregisterForNetworkAttached(this);
+                ImsPhoneConnection oldConnection = findConnection(callInfo.first);
+                if (oldConnection == null) {
+                    sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                }
+                mForegroundCall.detach(oldConnection);
+                removeConnection(oldConnection);
+                try {
+                    Connection newConnection =
+                            mPhone.getDefaultPhone().dial(mLastDialString, mLastDialArgs);
+                    oldConnection.onOriginalConnectionReplaced(newConnection);
+                } catch (CallStateException e) {
+                    sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                }
+                break;
+            }
+            case EVENT_REDIAL_WIFI_E911_TIMEOUT: {
+                Pair<ImsCall, ImsReasonInfo> callInfo = (Pair<ImsCall, ImsReasonInfo>) msg.obj;
+                mPhone.getDefaultPhone().getServiceStateTracker()
+                        .unregisterForNetworkAttached(this);
+                removeMessages(EVENT_REDIAL_WIFI_E911_CALL);
+                sendCallStartFailedDisconnect(callInfo.first, callInfo.second);
+                break;
+            }
         }
     }
 
-- 
2.17.1

