From f6de65667285be4bfbc2bf408260fc5638c6c73b Mon Sep 17 00:00:00 2001
From: Chavi Weingarten <chaviw@google.com>
Date: Mon, 14 May 2018 16:10:59 +0000
Subject: [PATCH 192/306] Revert "Prevent IME from targeting home when closing
 app is still animating"

This reverts commit 5e004f2798c81a0d24d4416afc5680ac0d6f4fe1.

Reason for revert: NPE crash
Fixes: 79672031
Fixes: 79670207

Change-Id: I0620d7ce182b6ee85d8c474e67ea8a899adde2b8
(cherry picked from commit 9e875b6251c4e7c07e4a850ae729b77f3992a8da)
---
 .../android/server/am/ActivityDisplay.java    | 14 ----
 .../com/android/server/am/ActivityStack.java  | 80 ++++++++-----------
 .../com/android/server/wm/DisplayContent.java | 55 +++----------
 .../server/wm/DisplayWindowController.java    | 25 ------
 .../com/android/server/wm/WindowState.java    |  2 +-
 5 files changed, 44 insertions(+), 132 deletions(-)

diff --git a/services/core/java/com/android/server/am/ActivityDisplay.java b/services/core/java/com/android/server/am/ActivityDisplay.java
index 698b6f7d99f..27eae57302b 100644
--- a/services/core/java/com/android/server/am/ActivityDisplay.java
+++ b/services/core/java/com/android/server/am/ActivityDisplay.java
@@ -800,20 +800,6 @@ class ActivityDisplay extends ConfigurationContainer<ActivityStack>
         }
     }
 
-    /**
-     * See {@link DisplayWindowController#deferUpdateImeTarget()}
-     */
-    public void deferUpdateImeTarget() {
-        mWindowContainerController.deferUpdateImeTarget();
-    }
-
-    /**
-     * See {@link DisplayWindowController#deferUpdateImeTarget()}
-     */
-    public void continueUpdateImeTarget() {
-        mWindowContainerController.continueUpdateImeTarget();
-    }
-
     public void dump(PrintWriter pw, String prefix) {
         pw.println(prefix + "displayId=" + mDisplayId + " stacks=" + mStacks.size());
         final String myPrefix = prefix + " ";
diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
index c18250272b7..87d36964823 100644
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -4595,58 +4595,46 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             }
         }
 
-        try {
-            // Defer updating the IME target since the new IME target will try to get computed
-            // before updating all closing and opening apps, which can cause the ime target to
-            // get calculated incorrectly.
-            getDisplay().deferUpdateImeTarget();
-
-            // Shift all activities with this task up to the top
-            // of the stack, keeping them in the same internal order.
-            insertTaskAtTop(tr, null);
-
-            // Don't refocus if invisible to current user
-            final ActivityRecord top = tr.getTopActivity();
-            if (top == null || !top.okToShowLocked()) {
-                if (top != null) {
-                    mStackSupervisor.mRecentTasks.add(top.getTask());
-                }
-                ActivityOptions.abort(options);
-                return;
-            }
-
-            // Set focus to the top running activity of this stack.
-            final ActivityRecord r = topRunningActivityLocked();
-            mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, reason);
+        // Shift all activities with this task up to the top
+        // of the stack, keeping them in the same internal order.
+        insertTaskAtTop(tr, null);
 
-            if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, "Prepare to front transition: task=" + tr);
-            if (noAnimation) {
-                mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
-                if (r != null) {
-                    mStackSupervisor.mNoAnimActivities.add(r);
-                }
-                ActivityOptions.abort(options);
-            } else {
-                updateTransitLocked(TRANSIT_TASK_TO_FRONT, options);
+        // Don't refocus if invisible to current user
+        final ActivityRecord top = tr.getTopActivity();
+        if (top == null || !top.okToShowLocked()) {
+            if (top != null) {
+                mStackSupervisor.mRecentTasks.add(top.getTask());
             }
-            // If a new task is moved to the front, then mark the existing top activity as
-            // supporting
+            ActivityOptions.abort(options);
+            return;
+        }
+
+        // Set focus to the top running activity of this stack.
+        final ActivityRecord r = topRunningActivityLocked();
+        mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, reason);
 
-            // picture-in-picture while paused only if the task would not be considered an oerlay
-            // on top
-            // of the current activity (eg. not fullscreen, or the assistant)
-            if (canEnterPipOnTaskSwitch(topActivity, tr, null /* toFrontActivity */,
-                    options)) {
-                topActivity.supportsEnterPipOnTaskSwitch = true;
+        if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, "Prepare to front transition: task=" + tr);
+        if (noAnimation) {
+            mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
+            if (r != null) {
+                mStackSupervisor.mNoAnimActivities.add(r);
             }
+            ActivityOptions.abort(options);
+        } else {
+            updateTransitLocked(TRANSIT_TASK_TO_FRONT, options);
+        }
+        // If a new task is moved to the front, then mark the existing top activity as supporting
+        // picture-in-picture while paused only if the task would not be considered an oerlay on top
+        // of the current activity (eg. not fullscreen, or the assistant)
+        if (canEnterPipOnTaskSwitch(topActivity, tr, null /* toFrontActivity */,
+                options)) {
+            topActivity.supportsEnterPipOnTaskSwitch = true;
+        }
 
-            mStackSupervisor.resumeFocusedStackTopActivityLocked();
-            EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT, tr.userId, tr.taskId);
+        mStackSupervisor.resumeFocusedStackTopActivityLocked();
+        EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT, tr.userId, tr.taskId);
 
-            mService.mTaskChangeNotificationController.notifyTaskMovedToFront(tr.taskId);
-        } finally {
-            getDisplay().continueUpdateImeTarget();
-        }
+        mService.mTaskChangeNotificationController.notifyTaskMovedToFront(tr.taskId);
     }
 
     /**
diff --git a/services/core/java/com/android/server/wm/DisplayContent.java b/services/core/java/com/android/server/wm/DisplayContent.java
index f3423c63e27..c0dc750949b 100644
--- a/services/core/java/com/android/server/wm/DisplayContent.java
+++ b/services/core/java/com/android/server/wm/DisplayContent.java
@@ -390,11 +390,6 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
      */
     int mLayoutSeq = 0;
 
-    /**
-     * Specifies the count to determine whether to defer updating the IME target until ready.
-     */
-    private int mDeferUpdateImeTargetCount;
-
     /** Temporary float array to retrieve 3x3 matrix values. */
     private final float[] mTmpFloats = new float[9];
 
@@ -2459,12 +2454,6 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
             return null;
         }
 
-        final WindowState curTarget = mService.mInputMethodTarget;
-        if (!canUpdateImeTarget()) {
-            if (DEBUG_INPUT_METHOD) Slog.w(TAG_WM, "Defer updating IME target");
-            return curTarget;
-        }
-
         // TODO(multidisplay): Needs some serious rethought when the target and IME are not on the
         // same display. Or even when the current IME/target are not on the same screen as the next
         // IME/target. For now only look for input windows on the main screen.
@@ -2488,13 +2477,16 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
         if (DEBUG_INPUT_METHOD && updateImeTarget) Slog.v(TAG_WM,
                 "Proposed new IME target: " + target);
 
-        // Now, a special case -- if the last target's window is in the process of exiting, and the
-        // new target is home, keep on the last target to avoid flicker. Home is a special case
-        // since its above other stacks in the ordering list, but layed out below the others.
+        // Now, a special case -- if the last target's window is in the process of exiting, and is
+        // above the new target, keep on the last target to avoid flicker. Consider for example a
+        // Dialog with the IME shown: when the Dialog is dismissed, we want to keep the IME above it
+        // until it is completely gone so it doesn't drop behind the dialog or its full-screen
+        // scrim.
+        final WindowState curTarget = mService.mInputMethodTarget;
         if (curTarget != null && curTarget.isDisplayedLw() && curTarget.isClosing()
-                && (target == null || target.isActivityTypeHome())) {
-            if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, "New target is home while current target is"
-                    + "closing, not changing");
+                && (target == null
+                    || curTarget.mWinAnimator.mAnimLayer > target.mWinAnimator.mAnimLayer)) {
+            if (DEBUG_INPUT_METHOD) Slog.v(TAG_WM, "Current target higher, not changing");
             return curTarget;
         }
 
@@ -3966,33 +3958,4 @@ class DisplayContent extends WindowContainer<DisplayContent.DisplayChildWindowCo
     void assignStackOrdering() {
         mTaskStackContainers.assignStackOrdering(getPendingTransaction());
     }
-
-    /**
-     * Increment the deferral count to determine whether to update the IME target.
-     */
-    void deferUpdateImeTarget() {
-        mDeferUpdateImeTargetCount++;
-    }
-
-    /**
-     * Decrement the deferral count to determine whether to update the IME target. If the count
-     * reaches 0, a new ime target will get computed.
-     */
-    void continueUpdateImeTarget() {
-        if (mDeferUpdateImeTargetCount == 0) {
-            return;
-        }
-
-        mDeferUpdateImeTargetCount--;
-        if (mDeferUpdateImeTargetCount == 0) {
-            computeImeTarget(true /* updateImeTarget */);
-        }
-    }
-
-    /**
-     * @return Whether a new IME target should be computed.
-     */
-    private boolean canUpdateImeTarget() {
-        return mDeferUpdateImeTargetCount == 0;
-    }
 }
diff --git a/services/core/java/com/android/server/wm/DisplayWindowController.java b/services/core/java/com/android/server/wm/DisplayWindowController.java
index a1639c2dd89..ba8ec69f360 100644
--- a/services/core/java/com/android/server/wm/DisplayWindowController.java
+++ b/services/core/java/com/android/server/wm/DisplayWindowController.java
@@ -94,31 +94,6 @@ public class DisplayWindowController
         }
     }
 
-    /**
-     * Starts deferring the ability to update the IME target. This is needed when a call will
-     * attempt to update the IME target before all information about the Windows have been updated.
-     */
-    public void deferUpdateImeTarget() {
-        synchronized (mWindowMap) {
-            final DisplayContent dc = mRoot.getDisplayContent(mDisplayId);
-            if (dc != null) {
-                dc.deferUpdateImeTarget();
-            }
-        }
-    }
-
-    /**
-     * Resumes updating the IME target after deferring. See {@link #deferUpdateImeTarget()}
-     */
-    public void continueUpdateImeTarget() {
-        synchronized (mWindowMap) {
-            final DisplayContent dc = mRoot.getDisplayContent(mDisplayId);
-            if (dc != null) {
-                dc.continueUpdateImeTarget();
-            }
-        }
-    }
-
     @Override
     public String toString() {
         return "{DisplayWindowController displayId=" + mDisplayId + "}";
diff --git a/services/core/java/com/android/server/wm/WindowState.java b/services/core/java/com/android/server/wm/WindowState.java
index 7883e2e63eb..c710c978900 100644
--- a/services/core/java/com/android/server/wm/WindowState.java
+++ b/services/core/java/com/android/server/wm/WindowState.java
@@ -2726,7 +2726,7 @@ class WindowState extends WindowContainer<WindowState> implements WindowManagerP
     }
 
     boolean isClosing() {
-        return mAnimatingExit || (mAppToken.isAnimating() && mAppToken.hiddenRequested);
+        return mAnimatingExit || (mService.mClosingApps.contains(mAppToken));
     }
 
     void addWinAnimatorToList(ArrayList<WindowStateAnimator> animators) {
-- 
2.17.1

