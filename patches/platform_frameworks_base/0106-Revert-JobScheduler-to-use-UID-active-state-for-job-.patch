From ef9026b3cdc61e56b887a5a5146a47a5cbf2b51d Mon Sep 17 00:00:00 2001
From: Artem Iglikov <artikz@google.com>
Date: Wed, 7 Feb 2018 09:47:51 +0000
Subject: [PATCH 106/306] Revert "JobScheduler to use UID active state for job
 exemption"

This reverts commit 6132e7bb1b428212a3a9d250a3dfebefc7894ea3.

Reason for revert: crashes master

Bug: 73049495
Change-Id: Idfd9a284163d26970b7cb89dea475d7c6abe0193
(cherry picked from commit 0b053fecb6ac9945172b3df5d9f1690b777cf42b)
---
 .../android/app/ActivityManagerInternal.java  |  5 -
 .../android/server/AlarmManagerService.java   | 33 +++----
 .../android/server/DeviceIdleController.java  |  8 +-
 ...acker.java => ForceAppStandbyTracker.java} | 80 +++++++--------
 .../java/com/android/server/StatLogger.java   | 11 +--
 .../server/am/ActivityManagerService.java     |  8 --
 .../server/job/JobSchedulerService.java       | 29 ++++--
 .../controllers/BackgroundJobsController.java | 38 +++----
 ...t.java => ForceAppStandbyTrackerTest.java} | 99 ++++++-------------
 9 files changed, 119 insertions(+), 192 deletions(-)
 rename services/core/java/com/android/server/{AppStateTracker.java => ForceAppStandbyTracker.java} (95%)
 rename services/tests/servicestests/src/com/android/server/{AppStateTrackerTest.java => ForceAppStandbyTrackerTest.java} (93%)

diff --git a/core/java/android/app/ActivityManagerInternal.java b/core/java/android/app/ActivityManagerInternal.java
index 4626cb274c0..5ee7edee9db 100644
--- a/core/java/android/app/ActivityManagerInternal.java
+++ b/core/java/android/app/ActivityManagerInternal.java
@@ -348,9 +348,4 @@ public abstract class ActivityManagerInternal {
      * Returns is the caller has the same uid as the Recents component
      */
     public abstract boolean isCallerRecents(int callingUid);
-
-    /**
-     * Whether an UID is active or idle.
-     */
-    public abstract boolean isUidActive(int uid);
 }
diff --git a/services/core/java/com/android/server/AlarmManagerService.java b/services/core/java/com/android/server/AlarmManagerService.java
index 355da2df87a..17c617c095d 100644
--- a/services/core/java/com/android/server/AlarmManagerService.java
+++ b/services/core/java/com/android/server/AlarmManagerService.java
@@ -98,8 +98,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.DumpUtils;
 import com.android.internal.util.LocalLog;
-import com.android.internal.util.Preconditions;
-import com.android.server.AppStateTracker.Listener;
+import com.android.server.ForceAppStandbyTracker.Listener;
 
 /**
  * Alarm manager implementaion.
@@ -250,7 +249,7 @@ class AlarmManagerService extends SystemService {
     private final SparseArray<AlarmManager.AlarmClockInfo> mHandlerSparseAlarmClockArray =
             new SparseArray<>();
 
-    private AppStateTracker mAppStateTracker;
+    private final ForceAppStandbyTracker mForceAppStandbyTracker;
     private boolean mAppStandbyParole;
     private ArrayMap<Pair<String, Integer>, Long> mLastAlarmDeliveredForPackage = new ArrayMap<>();
 
@@ -708,6 +707,9 @@ class AlarmManagerService extends SystemService {
         super(context);
         mConstants = new Constants(mHandler);
 
+        mForceAppStandbyTracker = ForceAppStandbyTracker.getInstance(context);
+        mForceAppStandbyTracker.addListener(mForceAppStandbyListener);
+
         publishLocalService(AlarmManagerInternal.class, new LocalService());
     }
 
@@ -1327,15 +1329,13 @@ class AlarmManagerService extends SystemService {
     @Override
     public void onBootPhase(int phase) {
         if (phase == PHASE_SYSTEM_SERVICES_READY) {
+            mForceAppStandbyTracker.start();
             mConstants.start(getContext().getContentResolver());
             mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);
             mLocalDeviceIdleController
                     = LocalServices.getService(DeviceIdleController.LocalService.class);
             mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);
             mUsageStatsManagerInternal.addAppIdleStateChangeListener(new AppStandbyTracker());
-
-            mAppStateTracker = LocalServices.getService(AppStateTracker.class);
-            mAppStateTracker.addListener(mForceAppStandbyListener);
         }
     }
 
@@ -1729,8 +1729,7 @@ class AlarmManagerService extends SystemService {
             // timing restrictions.
             } else if (workSource == null && (callingUid < Process.FIRST_APPLICATION_UID
                     || callingUid == mSystemUiUid
-                    || (mAppStateTracker != null
-                        && mAppStateTracker.isUidPowerSaveWhitelisted(callingUid)))) {
+                    || mForceAppStandbyTracker.isUidPowerSaveWhitelisted(callingUid))) {
                 flags |= AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED;
                 flags &= ~AlarmManager.FLAG_ALLOW_WHILE_IDLE;
             }
@@ -1813,10 +1812,8 @@ class AlarmManagerService extends SystemService {
             mConstants.dump(pw);
             pw.println();
 
-            if (mAppStateTracker != null) {
-                mAppStateTracker.dump(pw, "  ");
-                pw.println();
-            }
+            mForceAppStandbyTracker.dump(pw, "  ");
+            pw.println();
 
             pw.println("  App Standby Parole: " + mAppStandbyParole);
             pw.println();
@@ -2164,10 +2161,8 @@ class AlarmManagerService extends SystemService {
 
             mConstants.dumpProto(proto, AlarmManagerServiceProto.SETTINGS);
 
-            if (mAppStateTracker != null) {
-                mAppStateTracker.dumpProto(proto,
-                        AlarmManagerServiceProto.FORCE_APP_STANDBY_TRACKER);
-            }
+            mForceAppStandbyTracker.dumpProto(proto,
+                    AlarmManagerServiceProto.FORCE_APP_STANDBY_TRACKER);
 
             proto.write(AlarmManagerServiceProto.IS_INTERACTIVE, mInteractive);
             if (!mInteractive) {
@@ -2947,7 +2942,7 @@ class AlarmManagerService extends SystemService {
         }
         final String sourcePackage = alarm.sourcePackage;
         final int sourceUid = alarm.creatorUid;
-        return mAppStateTracker.areAlarmsRestricted(sourceUid, sourcePackage,
+        return mForceAppStandbyTracker.areAlarmsRestricted(sourceUid, sourcePackage,
                 allowWhileIdle);
     }
 
@@ -2960,7 +2955,7 @@ class AlarmManagerService extends SystemService {
 
     private long getWhileIdleMinIntervalLocked(int uid) {
         final boolean dozing = mPendingIdleUntil != null;
-        final boolean ebs = mAppStateTracker.isForceAllAppsStandbyEnabled();
+        final boolean ebs = mForceAppStandbyTracker.isForceAllAppsStandbyEnabled();
         if (!dozing && !ebs) {
             return mConstants.ALLOW_WHILE_IDLE_SHORT_TIME;
         }
@@ -4138,7 +4133,7 @@ class AlarmManagerService extends SystemService {
             if (allowWhileIdle) {
                 // Record the last time this uid handled an ALLOW_WHILE_IDLE alarm.
                 mLastAllowWhileIdleDispatch.put(alarm.creatorUid, nowELAPSED);
-                if (mAppStateTracker.isUidInForeground(alarm.creatorUid)) {
+                if (mForceAppStandbyTracker.isUidInForeground(alarm.creatorUid)) {
                     mUseAllowWhileIdleShortTime.put(alarm.creatorUid, true);
                 } else {
                     mUseAllowWhileIdleShortTime.put(alarm.creatorUid, false);
diff --git a/services/core/java/com/android/server/DeviceIdleController.java b/services/core/java/com/android/server/DeviceIdleController.java
index 2b3c5852ac8..44974ffd350 100644
--- a/services/core/java/com/android/server/DeviceIdleController.java
+++ b/services/core/java/com/android/server/DeviceIdleController.java
@@ -82,7 +82,6 @@ import com.android.internal.os.AtomicFile;
 import com.android.internal.os.BackgroundThread;
 import com.android.internal.util.DumpUtils;
 import com.android.internal.util.FastXmlSerializer;
-import com.android.internal.util.Preconditions;
 import com.android.internal.util.XmlUtils;
 import com.android.server.am.BatteryStatsService;
 import com.android.server.net.NetworkPolicyManagerInternal;
@@ -129,7 +128,6 @@ public class DeviceIdleController extends SystemService
     private Intent mIdleIntent;
     private Intent mLightIdleIntent;
     private AnyMotionDetector mAnyMotionDetector;
-    private final AppStateTracker mAppStateTracker;
     private boolean mLightEnabled;
     private boolean mDeepEnabled;
     private boolean mForceIdle;
@@ -1373,8 +1371,6 @@ public class DeviceIdleController extends SystemService
         super(context);
         mConfigFile = new AtomicFile(new File(getSystemDir(), "deviceidle.xml"));
         mHandler = new MyHandler(BackgroundThread.getHandler().getLooper());
-        mAppStateTracker = new AppStateTracker(context, FgThread.get().getLooper());
-        LocalServices.addService(AppStateTracker.class, mAppStateTracker);
     }
 
     boolean isAppOnWhitelistInternal(int appid) {
@@ -1505,8 +1501,6 @@ public class DeviceIdleController extends SystemService
                         (PowerManager) getContext().getSystemService(Context.POWER_SERVICE),
                         mHandler, mSensorManager, this, angleThreshold);
 
-                mAppStateTracker.onSystemServicesReady();
-
                 mIdleIntent = new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
                 mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                         | Intent.FLAG_RECEIVER_FOREGROUND);
@@ -2621,7 +2615,7 @@ public class DeviceIdleController extends SystemService
     }
 
     private void passWhiteListToForceAppStandbyTrackerLocked() {
-        mAppStateTracker.setPowerSaveWhitelistAppIds(
+        ForceAppStandbyTracker.getInstance(getContext()).setPowerSaveWhitelistAppIds(
                 mPowerSaveWhitelistExceptIdleAppIdArray,
                 mTempWhitelistAppIdArray);
     }
diff --git a/services/core/java/com/android/server/AppStateTracker.java b/services/core/java/com/android/server/ForceAppStandbyTracker.java
similarity index 95%
rename from services/core/java/com/android/server/AppStateTracker.java
rename to services/core/java/com/android/server/ForceAppStandbyTracker.java
index 51dff56d3c1..100680df637 100644
--- a/services/core/java/com/android/server/AppStateTracker.java
+++ b/services/core/java/com/android/server/ForceAppStandbyTracker.java
@@ -54,6 +54,7 @@ import com.android.internal.app.IAppOpsCallback;
 import com.android.internal.app.IAppOpsService;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.Preconditions;
+import com.android.server.DeviceIdleController.LocalService;
 import com.android.server.ForceAppStandbyTrackerProto.ExemptedPackage;
 import com.android.server.ForceAppStandbyTrackerProto.RunAnyInBackgroundRestrictedPackages;
 
@@ -72,14 +73,14 @@ import java.util.List;
  * TODO: Make it a LocalService.
  *
  * Test:
-  atest $ANDROID_BUILD_TOP/frameworks/base/services/tests/servicestests/src/com/android/server/AppStateTrackerTest.java
+  atest $ANDROID_BUILD_TOP/frameworks/base/services/tests/servicestests/src/com/android/server/ForceAppStandbyTrackerTest.java
  */
-public class AppStateTracker {
+public class ForceAppStandbyTracker {
     private static final String TAG = "ForceAppStandbyTracker";
     private static final boolean DEBUG = true;
 
-    @GuardedBy("AppStateTracker.class")
-    private static AppStateTracker sInstance;
+    @GuardedBy("ForceAppStandbyTracker.class")
+    private static ForceAppStandbyTracker sInstance;
 
     private final Object mLock = new Object();
     private final Context mContext;
@@ -88,7 +89,6 @@ public class AppStateTracker {
     static final int TARGET_OP = AppOpsManager.OP_RUN_ANY_IN_BACKGROUND;
 
     IActivityManager mIActivityManager;
-    ActivityManagerInternal mActivityManagerInternal;
     AppOpsManager mAppOpsManager;
     IAppOpsService mAppOpsService;
     PowerManagerInternal mPowerManagerInternal;
@@ -172,9 +172,6 @@ public class AppStateTracker {
         int EXEMPT_CHANGED = 6;
         int FORCE_ALL_CHANGED = 7;
         int FORCE_APP_STANDBY_FEATURE_FLAG_CHANGED = 8;
-
-        int IS_UID_ACTIVE_CACHED = 9;
-        int IS_UID_ACTIVE_RAW = 10;
     }
 
     private final StatLogger mStatLogger = new StatLogger(new String[] {
@@ -187,9 +184,6 @@ public class AppStateTracker {
             "EXEMPT_CHANGED",
             "FORCE_ALL_CHANGED",
             "FORCE_APP_STANDBY_FEATURE_FLAG_CHANGED",
-
-            "IS_UID_ACTIVE_CACHED",
-            "IS_UID_ACTIVE_RAW",
     });
 
     @VisibleForTesting
@@ -255,7 +249,7 @@ public class AppStateTracker {
         /**
          * This is called when the OP_RUN_ANY_IN_BACKGROUND appops changed for a package.
          */
-        private void onRunAnyAppOpsChanged(AppStateTracker sender,
+        private void onRunAnyAppOpsChanged(ForceAppStandbyTracker sender,
                 int uid, @NonNull String packageName) {
             updateJobsForUidPackage(uid, packageName);
 
@@ -270,14 +264,14 @@ public class AppStateTracker {
         /**
          * This is called when the foreground state changed for a UID.
          */
-        private void onUidForegroundStateChanged(AppStateTracker sender, int uid) {
+        private void onUidForegroundStateChanged(ForceAppStandbyTracker sender, int uid) {
             onUidForeground(uid, sender.isUidInForeground(uid));
         }
 
         /**
          * This is called when the active/idle state changed for a UID.
          */
-        private void onUidActiveStateChanged(AppStateTracker sender, int uid) {
+        private void onUidActiveStateChanged(ForceAppStandbyTracker sender, int uid) {
             updateJobsForUid(uid);
 
             if (sender.isUidActive(uid)) {
@@ -288,7 +282,7 @@ public class AppStateTracker {
         /**
          * This is called when an app-id(s) is removed from the power save whitelist.
          */
-        private void onPowerSaveUnwhitelisted(AppStateTracker sender) {
+        private void onPowerSaveUnwhitelisted(ForceAppStandbyTracker sender) {
             updateAllJobs();
             unblockAllUnrestrictedAlarms();
         }
@@ -297,14 +291,14 @@ public class AppStateTracker {
          * This is called when the power save whitelist changes, excluding the
          * {@link #onPowerSaveUnwhitelisted} case.
          */
-        private void onPowerSaveWhitelistedChanged(AppStateTracker sender) {
+        private void onPowerSaveWhitelistedChanged(ForceAppStandbyTracker sender) {
             updateAllJobs();
         }
 
         /**
          * This is called when the temp whitelist changes.
          */
-        private void onTempPowerSaveWhitelistChanged(AppStateTracker sender) {
+        private void onTempPowerSaveWhitelistChanged(ForceAppStandbyTracker sender) {
 
             // TODO This case happens rather frequently; consider optimizing and update jobs
             // only for affected app-ids.
@@ -317,7 +311,7 @@ public class AppStateTracker {
         /**
          * This is called when the EXEMPT bucket is updated.
          */
-        private void onExemptChanged(AppStateTracker sender) {
+        private void onExemptChanged(ForceAppStandbyTracker sender) {
             // This doesn't happen very often, so just re-evaluate all jobs / alarms.
             updateAllJobs();
             unblockAllUnrestrictedAlarms();
@@ -326,7 +320,7 @@ public class AppStateTracker {
         /**
          * This is called when the global "force all apps standby" flag changes.
          */
-        private void onForceAllAppsStandbyChanged(AppStateTracker sender) {
+        private void onForceAllAppsStandbyChanged(ForceAppStandbyTracker sender) {
             updateAllJobs();
 
             if (!sender.isForceAllAppsStandbyEnabled()) {
@@ -383,15 +377,30 @@ public class AppStateTracker {
         }
     }
 
-    public AppStateTracker(Context context, Looper looper) {
+    @VisibleForTesting
+    ForceAppStandbyTracker(Context context, Looper looper) {
         mContext = context;
         mHandler = new MyHandler(looper);
     }
 
+    private ForceAppStandbyTracker(Context context) {
+        this(context, FgThread.get().getLooper());
+    }
+
+    /**
+     * Get the singleton instance.
+     */
+    public static synchronized ForceAppStandbyTracker getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new ForceAppStandbyTracker(context);
+        }
+        return sInstance;
+    }
+
     /**
      * Call it when the system is ready.
      */
-    public void onSystemServicesReady() {
+    public void start() {
         synchronized (mLock) {
             if (mStarted) {
                 return;
@@ -399,7 +408,6 @@ public class AppStateTracker {
             mStarted = true;
 
             mIActivityManager = Preconditions.checkNotNull(injectIActivityManager());
-            mActivityManagerInternal = Preconditions.checkNotNull(injectActivityManagerInternal());
             mAppOpsManager = Preconditions.checkNotNull(injectAppOpsManager());
             mAppOpsService = Preconditions.checkNotNull(injectIAppOpsService());
             mPowerManagerInternal = Preconditions.checkNotNull(injectPowerManagerInternal());
@@ -466,11 +474,6 @@ public class AppStateTracker {
         return ActivityManager.getService();
     }
 
-    @VisibleForTesting
-    ActivityManagerInternal injectActivityManagerInternal() {
-        return LocalServices.getService(ActivityManagerInternal.class);
-    }
-
     @VisibleForTesting
     PowerManagerInternal injectPowerManagerInternal() {
         return LocalServices.getService(PowerManagerInternal.class);
@@ -796,7 +799,7 @@ public class AppStateTracker {
                     return;
                 }
             }
-            final AppStateTracker sender = AppStateTracker.this;
+            final ForceAppStandbyTracker sender = ForceAppStandbyTracker.this;
 
             long start = mStatLogger.getTime();
             switch (msg.what) {
@@ -1086,11 +1089,11 @@ public class AppStateTracker {
     }
 
     /**
-     * @return whether a UID is in active or not *based on cached information.*
+     * @return whether a UID is in active or not.
      *
      * Note this information is based on the UID proc state callback, meaning it's updated
      * asynchronously and may subtly be stale. If the fresh data is needed, use
-     * {@link #isUidActiveSynced} instead.
+     * {@link ActivityManagerInternal#getUidProcessState} instead.
      */
     public boolean isUidActive(int uid) {
         if (UserHandle.isCore(uid)) {
@@ -1101,23 +1104,6 @@ public class AppStateTracker {
         }
     }
 
-    /**
-     * @return whether a UID is in active or not *right now.*
-     *
-     * This gives the fresh information, but may access the activity manager so is slower.
-     */
-    public boolean isUidActiveSynced(int uid) {
-        if (isUidActive(uid)) { // Use the cached one first.
-            return true;
-        }
-        final long start = mStatLogger.getTime();
-
-        final boolean ret = mActivityManagerInternal.isUidActive(uid);
-        mStatLogger.logDurationStat(Stats.IS_UID_ACTIVE_RAW, start);
-
-        return ret;
-    }
-
     /**
      * @return whether a UID is in the foreground or not.
      *
diff --git a/services/core/java/com/android/server/StatLogger.java b/services/core/java/com/android/server/StatLogger.java
index 0e6f5e2338c..f2117314df0 100644
--- a/services/core/java/com/android/server/StatLogger.java
+++ b/services/core/java/com/android/server/StatLogger.java
@@ -17,7 +17,6 @@
 package com.android.server;
 
 import android.os.SystemClock;
-import android.util.Slog;
 import android.util.proto.ProtoOutputStream;
 
 import com.android.internal.annotations.GuardedBy;
@@ -34,8 +33,6 @@ import java.io.PrintWriter;
  * @hide
  */
 public class StatLogger {
-    private static final String TAG = "StatLogger";
-
     private final Object mLock = new Object();
 
     private final int SIZE;
@@ -69,12 +66,8 @@ public class StatLogger {
      */
     public void logDurationStat(int eventId, long start) {
         synchronized (mLock) {
-            if (eventId >= 0 && eventId < SIZE) {
-                mCountStats[eventId]++;
-                mDurationStats[eventId] += (getTime() - start);
-            } else {
-                Slog.wtf(TAG, "Invalid event ID: " + eventId);
-            }
+            mCountStats[eventId]++;
+            mDurationStats[eventId] += (getTime() - start);
         }
     }
 
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 9db4e2b4e4c..a6c4fc95283 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -25863,14 +25863,6 @@ public class ActivityManagerService extends IActivityManager.Stub
         public boolean isCallerRecents(int callingUid) {
             return getRecentTasks().isCallerRecents(callingUid);
         }
-
-        @Override
-        public boolean isUidActive(int uid) {
-            synchronized (ActivityManagerService.this) {
-                final UidRecord uidRec = mActiveUids.get(uid);
-                return (uidRec != null) && !uidRec.idle;
-            }
-        }
     }
 
     /**
diff --git a/services/core/java/com/android/server/job/JobSchedulerService.java b/services/core/java/com/android/server/job/JobSchedulerService.java
index 47a4fb24201..401c05e8030 100644
--- a/services/core/java/com/android/server/job/JobSchedulerService.java
+++ b/services/core/java/com/android/server/job/JobSchedulerService.java
@@ -40,6 +40,7 @@ import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.Intent.UriFlags;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
@@ -78,7 +79,7 @@ import com.android.internal.util.DumpUtils;
 import com.android.internal.util.Preconditions;
 import com.android.server.DeviceIdleController;
 import com.android.server.FgThread;
-import com.android.server.AppStateTracker;
+import com.android.server.ForceAppStandbyTracker;
 import com.android.server.LocalServices;
 import com.android.server.job.JobSchedulerServiceDumpProto.ActiveJob;
 import com.android.server.job.JobSchedulerServiceDumpProto.PendingJob;
@@ -183,7 +184,7 @@ public final class JobSchedulerService extends com.android.server.SystemService
     ActivityManagerInternal mActivityManagerInternal;
     IBatteryStats mBatteryStats;
     DeviceIdleController.LocalService mLocalDeviceIdleController;
-    AppStateTracker mAppStateTracker;
+    final ForceAppStandbyTracker mForceAppStandbyTracker;
 
     /**
      * Set to true once we are allowed to run third party apps.
@@ -786,13 +787,20 @@ public final class JobSchedulerService extends com.android.server.SystemService
     }
 
     /**
-     * Return whether an UID is active or idle.
+     * Return whether an UID is in the foreground or not.
      */
-    private boolean isUidActive(int uid) {
-        return mAppStateTracker.isUidActiveSynced(uid);
+    private boolean isUidInForeground(int uid) {
+        synchronized (mLock) {
+            if (mUidPriorityOverride.get(uid, 0) > 0) {
+                return true;
+            }
+        }
+        // Note UID observer may not be called in time, so we always check with the AM.
+        return mActivityManagerInternal.getUidProcessState(uid)
+                <= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
     }
 
-    private final Predicate<Integer> mIsUidActivePredicate = this::isUidActive;
+    private final Predicate<Integer> mIsUidInForegroundPredicate = this::isUidInForeground;
 
     public int scheduleAsPackage(JobInfo job, JobWorkItem work, int uId, String packageName,
             int userId, String tag) {
@@ -818,7 +826,7 @@ public final class JobSchedulerService extends com.android.server.SystemService
 
                     // If any of work item is enqueued when the source is in the foreground,
                     // exempt the entire job.
-                    toCancel.maybeAddForegroundExemption(mIsUidActivePredicate);
+                    toCancel.maybeAddForegroundExemption(mIsUidInForegroundPredicate);
 
                     return JobScheduler.RESULT_SUCCESS;
                 }
@@ -830,7 +838,7 @@ public final class JobSchedulerService extends com.android.server.SystemService
             // Note if it's a sync job, this method is called on the handler so it's not exactly
             // the state when requestSync() was called, but that should be fine because of the
             // 1 minute foreground grace period.
-            jobStatus.maybeAddForegroundExemption(mIsUidActivePredicate);
+            jobStatus.maybeAddForegroundExemption(mIsUidInForegroundPredicate);
 
             if (DEBUG) Slog.d(TAG, "SCHEDULE: " + jobStatus.toShortString());
             // Jobs on behalf of others don't apply to the per-app job cap
@@ -1115,6 +1123,8 @@ public final class JobSchedulerService extends com.android.server.SystemService
         mDeviceIdleJobsController = DeviceIdleJobsController.get(this);
         mControllers.add(mDeviceIdleJobsController);
 
+        mForceAppStandbyTracker = ForceAppStandbyTracker.getInstance(context);
+
         // If the job store determined that it can't yet reschedule persisted jobs,
         // we need to start watching the clock.
         if (!mJobs.jobTimesInflatedValid()) {
@@ -1175,8 +1185,7 @@ public final class JobSchedulerService extends com.android.server.SystemService
         if (PHASE_SYSTEM_SERVICES_READY == phase) {
             mConstants.start(getContext().getContentResolver());
 
-            mAppStateTracker = Preconditions.checkNotNull(
-                    LocalServices.getService(AppStateTracker.class));
+            mForceAppStandbyTracker.start();
 
             // Register br for package removals and user removals.
             final IntentFilter filter = new IntentFilter();
diff --git a/services/core/java/com/android/server/job/controllers/BackgroundJobsController.java b/services/core/java/com/android/server/job/controllers/BackgroundJobsController.java
index e8057fbd415..5eb77000a4f 100644
--- a/services/core/java/com/android/server/job/controllers/BackgroundJobsController.java
+++ b/services/core/java/com/android/server/job/controllers/BackgroundJobsController.java
@@ -22,10 +22,8 @@ import android.os.UserHandle;
 import android.util.Slog;
 import android.util.proto.ProtoOutputStream;
 
-import com.android.internal.util.Preconditions;
-import com.android.server.AppStateTracker;
-import com.android.server.AppStateTracker.Listener;
-import com.android.server.LocalServices;
+import com.android.server.ForceAppStandbyTracker;
+import com.android.server.ForceAppStandbyTracker.Listener;
 import com.android.server.job.JobSchedulerService;
 import com.android.server.job.JobStore;
 import com.android.server.job.StateControllerProto;
@@ -44,7 +42,8 @@ public final class BackgroundJobsController extends StateController {
 
     private final JobSchedulerService mJobSchedulerService;
 
-    private final AppStateTracker mAppStateTracker;
+    private final ForceAppStandbyTracker mForceAppStandbyTracker;
+
 
     public static BackgroundJobsController get(JobSchedulerService service) {
         synchronized (sCreationLock) {
@@ -60,9 +59,10 @@ public final class BackgroundJobsController extends StateController {
         super(service, context, lock);
         mJobSchedulerService = service;
 
-        mAppStateTracker = Preconditions.checkNotNull(
-                LocalServices.getService(AppStateTracker.class));
-        mAppStateTracker.addListener(mForceAppStandbyListener);
+        mForceAppStandbyTracker = ForceAppStandbyTracker.getInstance(context);
+
+        mForceAppStandbyTracker.addListener(mForceAppStandbyListener);
+        mForceAppStandbyTracker.start();
     }
 
     @Override
@@ -79,7 +79,7 @@ public final class BackgroundJobsController extends StateController {
     public void dumpControllerStateLocked(final PrintWriter pw, final int filterUid) {
         pw.println("BackgroundJobsController");
 
-        mAppStateTracker.dump(pw, "");
+        mForceAppStandbyTracker.dump(pw, "");
 
         pw.println("Job state:");
         mJobSchedulerService.getJobStore().forEachJob((jobStatus) -> {
@@ -92,16 +92,16 @@ public final class BackgroundJobsController extends StateController {
             jobStatus.printUniqueId(pw);
             pw.print(" from ");
             UserHandle.formatUid(pw, uid);
-            pw.print(mAppStateTracker.isUidActive(uid) ? " active" : " idle");
-            if (mAppStateTracker.isUidPowerSaveWhitelisted(uid) ||
-                    mAppStateTracker.isUidTempPowerSaveWhitelisted(uid)) {
+            pw.print(mForceAppStandbyTracker.isUidActive(uid) ? " active" : " idle");
+            if (mForceAppStandbyTracker.isUidPowerSaveWhitelisted(uid) ||
+                    mForceAppStandbyTracker.isUidTempPowerSaveWhitelisted(uid)) {
                 pw.print(", whitelisted");
             }
             pw.print(": ");
             pw.print(sourcePkg);
 
             pw.print(" [RUN_ANY_IN_BACKGROUND ");
-            pw.print(mAppStateTracker.isRunAnyInBackgroundAppOpsAllowed(uid, sourcePkg)
+            pw.print(mForceAppStandbyTracker.isRunAnyInBackgroundAppOpsAllowed(uid, sourcePkg)
                     ? "allowed]" : "disallowed]");
 
             if ((jobStatus.satisfiedConstraints
@@ -118,7 +118,7 @@ public final class BackgroundJobsController extends StateController {
         final long token = proto.start(fieldId);
         final long mToken = proto.start(StateControllerProto.BACKGROUND);
 
-        mAppStateTracker.dumpProto(proto,
+        mForceAppStandbyTracker.dumpProto(proto,
                 StateControllerProto.BackgroundJobsController.FORCE_APP_STANDBY_TRACKER);
 
         mJobSchedulerService.getJobStore().forEachJob((jobStatus) -> {
@@ -136,14 +136,14 @@ public final class BackgroundJobsController extends StateController {
             proto.write(TrackedJob.SOURCE_PACKAGE_NAME, sourcePkg);
 
             proto.write(TrackedJob.IS_IN_FOREGROUND,
-                    mAppStateTracker.isUidActive(sourceUid));
+                    mForceAppStandbyTracker.isUidActive(sourceUid));
             proto.write(TrackedJob.IS_WHITELISTED,
-                    mAppStateTracker.isUidPowerSaveWhitelisted(sourceUid) ||
-                    mAppStateTracker.isUidTempPowerSaveWhitelisted(sourceUid));
+                    mForceAppStandbyTracker.isUidPowerSaveWhitelisted(sourceUid) ||
+                    mForceAppStandbyTracker.isUidTempPowerSaveWhitelisted(sourceUid));
 
             proto.write(
                     TrackedJob.CAN_RUN_ANY_IN_BACKGROUND,
-                    mAppStateTracker.isRunAnyInBackgroundAppOpsAllowed(
+                    mForceAppStandbyTracker.isRunAnyInBackgroundAppOpsAllowed(
                             sourceUid, sourcePkg));
 
             proto.write(
@@ -197,7 +197,7 @@ public final class BackgroundJobsController extends StateController {
         final int uid = jobStatus.getSourceUid();
         final String packageName = jobStatus.getSourcePackageName();
 
-        final boolean canRun = !mAppStateTracker.areJobsRestricted(uid, packageName,
+        final boolean canRun = !mForceAppStandbyTracker.areJobsRestricted(uid, packageName,
                 (jobStatus.getInternalFlags() & JobStatus.INTERNAL_FLAG_HAS_FOREGROUND_EXEMPTION)
                         != 0);
 
diff --git a/services/tests/servicestests/src/com/android/server/AppStateTrackerTest.java b/services/tests/servicestests/src/com/android/server/ForceAppStandbyTrackerTest.java
similarity index 93%
rename from services/tests/servicestests/src/com/android/server/AppStateTrackerTest.java
rename to services/tests/servicestests/src/com/android/server/ForceAppStandbyTrackerTest.java
index 90db2a328c6..a499472d197 100644
--- a/services/tests/servicestests/src/com/android/server/AppStateTrackerTest.java
+++ b/services/tests/servicestests/src/com/android/server/ForceAppStandbyTrackerTest.java
@@ -15,7 +15,7 @@
  */
 package com.android.server;
 
-import static com.android.server.AppStateTracker.TARGET_OP;
+import static com.android.server.ForceAppStandbyTracker.TARGET_OP;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -33,7 +33,6 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.app.ActivityManager;
-import android.app.ActivityManagerInternal;
 import android.app.AppOpsManager;
 import android.app.AppOpsManager.OpEntry;
 import android.app.AppOpsManager.PackageOps;
@@ -64,7 +63,7 @@ import android.util.Pair;
 
 import com.android.internal.app.IAppOpsCallback;
 import com.android.internal.app.IAppOpsService;
-import com.android.server.AppStateTracker.Listener;
+import com.android.server.ForceAppStandbyTracker.Listener;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -83,17 +82,17 @@ import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 
 /**
- * Tests for {@link AppStateTracker}
+ * Tests for {@link ForceAppStandbyTracker}
  *
  * Run with:
- atest $ANDROID_BUILD_TOP/frameworks/base/services/tests/servicestests/src/com/android/server/AppStateTrackerTest.java
+ atest $ANDROID_BUILD_TOP/frameworks/base/services/tests/servicestests/src/com/android/server/ForceAppStandbyTrackerTest.java
  */
 @SmallTest
 @RunWith(AndroidJUnit4.class)
-public class AppStateTrackerTest {
+public class ForceAppStandbyTrackerTest {
 
-    private class AppStateTrackerTestable extends AppStateTracker {
-        AppStateTrackerTestable() {
+    private class ForceAppStandbyTrackerTestable extends ForceAppStandbyTracker {
+        ForceAppStandbyTrackerTestable() {
             super(mMockContext, Looper.getMainLooper());
         }
 
@@ -112,11 +111,6 @@ public class AppStateTrackerTest {
             return mMockIActivityManager;
         }
 
-        @Override
-        ActivityManagerInternal injectActivityManagerInternal() {
-            return mMockIActivityManagerInternal;
-        }
-
         @Override
         PowerManagerInternal injectPowerManagerInternal() {
             return mMockPowerManagerInternal;
@@ -157,9 +151,6 @@ public class AppStateTrackerTest {
     @Mock
     private IActivityManager mMockIActivityManager;
 
-    @Mock
-    private ActivityManagerInternal mMockIActivityManagerInternal;
-
     @Mock
     private AppOpsManager mMockAppOpsManager;
 
@@ -204,7 +195,7 @@ public class AppStateTrackerTest {
         return new PowerSaveState.Builder().setBatterySaverEnabled(mPowerSaveMode).build();
     }
 
-    private AppStateTrackerTestable newInstance() throws Exception {
+    private ForceAppStandbyTrackerTestable newInstance() throws Exception {
         MockitoAnnotations.initMocks(this);
 
         when(mMockIAppOpsService.checkOperation(eq(TARGET_OP), anyInt(), anyString()))
@@ -214,12 +205,12 @@ public class AppStateTrackerTest {
                             AppOpsManager.MODE_IGNORED : AppOpsManager.MODE_ALLOWED;
                 });
 
-        final AppStateTrackerTestable instance = new AppStateTrackerTestable();
+        final ForceAppStandbyTrackerTestable instance = new ForceAppStandbyTrackerTestable();
 
         return instance;
     }
 
-    private void callStart(AppStateTrackerTestable instance) throws RemoteException {
+    private void callStart(ForceAppStandbyTrackerTestable instance) throws RemoteException {
 
         // Set up functions that start() calls.
         when(mMockPowerManagerInternal.getLowPowerState(eq(ServiceType.FORCE_ALL_APPS_STANDBY)))
@@ -232,7 +223,7 @@ public class AppStateTrackerTest {
         when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
 
         // Call start.
-        instance.onSystemServicesReady();
+        instance.start();
 
         // Capture the listeners.
         ArgumentCaptor<IUidObserver> uidObserverArgumentCaptor =
@@ -296,7 +287,7 @@ public class AppStateTrackerTest {
     private static final int JOBS_ONLY = 1 << 1;
     private static final int JOBS_AND_ALARMS = ALARMS_ONLY | JOBS_ONLY;
 
-    private void areRestricted(AppStateTrackerTestable instance, int uid, String packageName,
+    private void areRestricted(ForceAppStandbyTrackerTestable instance, int uid, String packageName,
             int restrictionTypes, boolean exemptFromBatterySaver) {
         assertEquals(((restrictionTypes & JOBS_ONLY) != 0),
                 instance.areJobsRestricted(uid, packageName, exemptFromBatterySaver));
@@ -304,13 +295,13 @@ public class AppStateTrackerTest {
                 instance.areAlarmsRestricted(uid, packageName, exemptFromBatterySaver));
     }
 
-    private void areRestricted(AppStateTrackerTestable instance, int uid, String packageName,
+    private void areRestricted(ForceAppStandbyTrackerTestable instance, int uid, String packageName,
             int restrictionTypes) {
         areRestricted(instance, uid, packageName, restrictionTypes,
                 /*exemptFromBatterySaver=*/ false);
     }
 
-    private void areRestrictedWithExemption(AppStateTrackerTestable instance,
+    private void areRestrictedWithExemption(ForceAppStandbyTrackerTestable instance,
             int uid, String packageName, int restrictionTypes) {
         areRestricted(instance, uid, packageName, restrictionTypes,
                 /*exemptFromBatterySaver=*/ true);
@@ -318,7 +309,7 @@ public class AppStateTrackerTest {
 
     @Test
     public void testAll() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
         assertFalse(instance.isForceAllAppsStandbyEnabled());
@@ -475,7 +466,7 @@ public class AppStateTrackerTest {
 
     @Test
     public void testUidStateForeground() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
         mIUidObserver.onUidActive(UID_1);
@@ -485,10 +476,6 @@ public class AppStateTrackerTest {
         assertFalse(instance.isUidActive(UID_2));
         assertTrue(instance.isUidActive(Process.SYSTEM_UID));
 
-        assertTrue(instance.isUidActiveSynced(UID_1));
-        assertFalse(instance.isUidActiveSynced(UID_2));
-        assertTrue(instance.isUidActiveSynced(Process.SYSTEM_UID));
-
         assertFalse(instance.isUidInForeground(UID_1));
         assertFalse(instance.isUidInForeground(UID_2));
         assertTrue(instance.isUidInForeground(Process.SYSTEM_UID));
@@ -502,10 +489,6 @@ public class AppStateTrackerTest {
         assertFalse(instance.isUidActive(UID_2));
         assertTrue(instance.isUidActive(Process.SYSTEM_UID));
 
-        assertTrue(instance.isUidActiveSynced(UID_1));
-        assertFalse(instance.isUidActiveSynced(UID_2));
-        assertTrue(instance.isUidActiveSynced(Process.SYSTEM_UID));
-
         assertFalse(instance.isUidInForeground(UID_1));
         assertTrue(instance.isUidInForeground(UID_2));
         assertTrue(instance.isUidInForeground(Process.SYSTEM_UID));
@@ -565,34 +548,14 @@ public class AppStateTrackerTest {
         assertFalse(instance.isUidActive(UID_2));
         assertTrue(instance.isUidActive(Process.SYSTEM_UID));
 
-        assertFalse(instance.isUidActiveSynced(UID_1));
-        assertFalse(instance.isUidActiveSynced(UID_2));
-        assertTrue(instance.isUidActiveSynced(Process.SYSTEM_UID));
-
         assertFalse(instance.isUidInForeground(UID_1));
         assertFalse(instance.isUidInForeground(UID_2));
         assertTrue(instance.isUidInForeground(Process.SYSTEM_UID));
-
-        // The result from AMI.isUidActive() only affects isUidActiveSynced().
-        when(mMockIActivityManagerInternal.isUidActive(anyInt())).thenReturn(true);
-
-        assertFalse(instance.isUidActive(UID_1));
-        assertFalse(instance.isUidActive(UID_2));
-        assertTrue(instance.isUidActive(Process.SYSTEM_UID));
-
-        assertTrue(instance.isUidActiveSynced(UID_1));
-        assertTrue(instance.isUidActiveSynced(UID_2));
-        assertTrue(instance.isUidActiveSynced(Process.SYSTEM_UID));
-
-        assertFalse(instance.isUidInForeground(UID_1));
-        assertFalse(instance.isUidInForeground(UID_2));
-        assertTrue(instance.isUidInForeground(Process.SYSTEM_UID));
-
     }
 
     @Test
     public void testExempt() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
         assertFalse(instance.isForceAllAppsStandbyEnabled());
@@ -658,7 +621,7 @@ public class AppStateTrackerTest {
     }
 
     public void loadPersistedAppOps() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
 
         final List<PackageOps> ops = new ArrayList<>();
 
@@ -668,7 +631,7 @@ public class AppStateTrackerTest {
                 AppOpsManager.OP_ACCESS_NOTIFICATIONS,
                 AppOpsManager.MODE_IGNORED, 0, 0, 0, 0, null));
         entries.add(new AppOpsManager.OpEntry(
-                AppStateTracker.TARGET_OP,
+                ForceAppStandbyTracker.TARGET_OP,
                 AppOpsManager.MODE_IGNORED, 0, 0, 0, 0, null));
 
         ops.add(new PackageOps(PACKAGE_1, UID_1, entries));
@@ -676,7 +639,7 @@ public class AppStateTrackerTest {
         //--------------------------------------------------
         entries = new ArrayList<>();
         entries.add(new AppOpsManager.OpEntry(
-                AppStateTracker.TARGET_OP,
+                ForceAppStandbyTracker.TARGET_OP,
                 AppOpsManager.MODE_IGNORED, 0, 0, 0, 0, null));
 
         ops.add(new PackageOps(PACKAGE_2, UID_2, entries));
@@ -684,7 +647,7 @@ public class AppStateTrackerTest {
         //--------------------------------------------------
         entries = new ArrayList<>();
         entries.add(new AppOpsManager.OpEntry(
-                AppStateTracker.TARGET_OP,
+                ForceAppStandbyTracker.TARGET_OP,
                 AppOpsManager.MODE_ALLOWED, 0, 0, 0, 0, null));
 
         ops.add(new PackageOps(PACKAGE_1, UID_10_1, entries));
@@ -692,7 +655,7 @@ public class AppStateTrackerTest {
         //--------------------------------------------------
         entries = new ArrayList<>();
         entries.add(new AppOpsManager.OpEntry(
-                AppStateTracker.TARGET_OP,
+                ForceAppStandbyTracker.TARGET_OP,
                 AppOpsManager.MODE_IGNORED, 0, 0, 0, 0, null));
         entries.add(new AppOpsManager.OpEntry(
                 AppOpsManager.OP_ACCESS_NOTIFICATIONS,
@@ -725,10 +688,10 @@ public class AppStateTrackerTest {
 
     @Test
     public void testPowerSaveListener() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
-        AppStateTracker.Listener l = mock(AppStateTracker.Listener.class);
+        ForceAppStandbyTracker.Listener l = mock(ForceAppStandbyTracker.Listener.class);
         instance.addListener(l);
 
         // Power save on.
@@ -768,10 +731,10 @@ public class AppStateTrackerTest {
 
     @Test
     public void testAllListeners() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
-        AppStateTracker.Listener l = mock(AppStateTracker.Listener.class);
+        ForceAppStandbyTracker.Listener l = mock(ForceAppStandbyTracker.Listener.class);
         instance.addListener(l);
 
         // -------------------------------------------------------------------------
@@ -1079,7 +1042,7 @@ public class AppStateTrackerTest {
 
     @Test
     public void testUserRemoved() throws Exception {
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
 
         mIUidObserver.onUidActive(UID_1);
@@ -1114,7 +1077,7 @@ public class AppStateTrackerTest {
         // This is a small battery device
         mIsSmallBatteryDevice = true;
 
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
         assertFalse(instance.isForceAllAppsStandbyEnabled());
 
@@ -1140,7 +1103,7 @@ public class AppStateTrackerTest {
         // Not a small battery device, so plugged in status should not affect forced app standby
         mIsSmallBatteryDevice = false;
 
-        final AppStateTrackerTestable instance = newInstance();
+        final ForceAppStandbyTrackerTestable instance = newInstance();
         callStart(instance);
         assertFalse(instance.isForceAllAppsStandbyEnabled());
 
@@ -1189,7 +1152,7 @@ public class AppStateTrackerTest {
 
     private void checkAnyAppIdUnwhitelisted(int[] prevArray, int[] newArray, boolean expected) {
         assertEquals("Input: " + Arrays.toString(prevArray) + " " + Arrays.toString(newArray),
-                expected, AppStateTracker.isAnyAppIdUnwhitelisted(prevArray, newArray));
+                expected, ForceAppStandbyTracker.isAnyAppIdUnwhitelisted(prevArray, newArray));
 
         // Also test isAnyAppIdUnwhitelistedSlow.
         assertEquals("Input: " + Arrays.toString(prevArray) + " " + Arrays.toString(newArray),
@@ -1221,7 +1184,7 @@ public class AppStateTrackerTest {
             final int[] array2 = makeRandomArray();
 
             final boolean expected = isAnyAppIdUnwhitelistedSlow(array1, array2);
-            final boolean actual = AppStateTracker.isAnyAppIdUnwhitelisted(array1, array2);
+            final boolean actual = ForceAppStandbyTracker.isAnyAppIdUnwhitelisted(array1, array2);
 
             assertEquals("Input: " + Arrays.toString(array1) + " " + Arrays.toString(array2),
                     expected, actual);
-- 
2.17.1

