From b8371d532d6cd1314954c2d3e9b8a79d3d70e7c7 Mon Sep 17 00:00:00 2001
From: Hridya Valsaraju <hridya@google.com>
Date: Thu, 31 May 2018 12:39:58 -0700
Subject: [PATCH 01/29] Populate recovery DTBO offset correctly

Also, remove recovery_dtbo_offset argument
for mkbootimg as this is calculated based
on sizes of kernel, ramdisk and second
binaries.

Also, modify unpack_bootimg to use the recovery_dtbo_offset
field to extract recovery_dtbo.

Test: make recoveryimage showcommands -j32
Bug: 80207223
unpack_bootimg --boot_img $OUT/recovery.img
diff recovery_dtbo dtbo.img

Change-Id: I588ccc8b739c169b6f78c17ffe554c5562397d98
Merged-In: I588ccc8b739c169b6f78c17ffe554c5562397d98
(cherry picked from commit 26e01bbdc5cb2dcad64d73ec836447b8ded4fc6c)
---
 mkbootimg/mkbootimg      | 27 ++++++++++++++++++++++-----
 mkbootimg/unpack_bootimg |  9 +++------
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/mkbootimg/mkbootimg b/mkbootimg/mkbootimg
index ac20d0503..fda9af0d2 100755
--- a/mkbootimg/mkbootimg
+++ b/mkbootimg/mkbootimg
@@ -45,6 +45,22 @@ def pad_file(f, padding):
     f.write(pack(str(pad) + 'x'))
 
 
+def get_number_of_pages(image_size, page_size):
+    """calculates the number of pages required for the image"""
+    return (image_size + page_size - 1) / page_size
+
+
+def get_recovery_dtbo_offset(args):
+    """calculates the offset of recovery_dtbo image in the boot image"""
+    num_header_pages = 1 # header occupies a page
+    num_kernel_pages = get_number_of_pages(filesize(args.kernel), args.pagesize)
+    num_ramdisk_pages = get_number_of_pages(filesize(args.ramdisk), args.pagesize)
+    num_second_pages = get_number_of_pages(filesize(args.second), args.pagesize)
+    dtbo_offset = args.pagesize * (num_header_pages + num_kernel_pages +
+                                   num_ramdisk_pages + num_second_pages)
+    return dtbo_offset
+
+
 def write_header(args):
     BOOT_MAGIC = 'ANDROID!'.encode()
     args.output.write(pack('8s', BOOT_MAGIC))
@@ -76,9 +92,12 @@ def write_header(args):
     args.output.write(pack('1024s', args.cmdline[512:].encode()))
 
     if args.header_version > 0:
-        args.output.write(pack('I', filesize(args.recovery_dtbo)))           # size in bytes
-        args.output.write(pack('Q', args.base + args.recovery_dtbo_offset))  # physical load addr
-        args.output.write(pack('I', args.output.tell() + 4))                 # size of boot header
+        args.output.write(pack('I', filesize(args.recovery_dtbo)))   # size in bytes
+        if args.recovery_dtbo:
+            args.output.write(pack('Q', get_recovery_dtbo_offset(args))) # recovery dtbo offset
+        else:
+            args.output.write(pack('Q', 0)) # Will be set to 0 for devices without a recovery dtbo
+        args.output.write(pack('I', args.output.tell() + 4))         # size of boot header
 
     pad_file(args.output, args.pagesize)
     return img_id
@@ -150,8 +169,6 @@ def parse_cmdline():
     parser.add_argument('--ramdisk_offset', help='ramdisk offset', type=parse_int, default=0x01000000)
     parser.add_argument('--second_offset', help='2nd bootloader offset', type=parse_int,
                         default=0x00f00000)
-    parser.add_argument('--recovery_dtbo_offset', help='recovery dtbo offset', type=parse_int,
-                        default=0x0f000000)
     parser.add_argument('--os_version', help='operating system version', type=parse_os_version,
                         default=0)
     parser.add_argument('--os_patch_level', help='operating system patch level',
diff --git a/mkbootimg/unpack_bootimg b/mkbootimg/unpack_bootimg
index 8e42ec029..c37acd5ac 100755
--- a/mkbootimg/unpack_bootimg
+++ b/mkbootimg/unpack_bootimg
@@ -76,8 +76,8 @@ def unpack_bootimage(args):
     if version > 0:
         recovery_dtbo_size = unpack('I', args.boot_img.read(1 * 4))[0]
         print('recovery dtbo size: %s' % recovery_dtbo_size)
-        recovery_dtbo_address = unpack('Q', args.boot_img.read(8))[0]
-        print('recovery dtbo load address: %s' % recovery_dtbo_address)
+        recovery_dtbo_offset = unpack('Q', args.boot_img.read(8))[0]
+        print('recovery dtbo offset: %s' % recovery_dtbo_offset)
         boot_header_size = unpack('I', args.boot_img.read(4))[0]
         print('boot header size: %s' % boot_header_size)
     else:
@@ -95,16 +95,13 @@ def unpack_bootimage(args):
                                  ) # header + kernel
     image_info_list.append((ramdisk_offset, ramdisk_size, 'ramdisk'))
 
-    num_second_pages = get_number_of_pages(second_size, page_size)
     second_offset = page_size * (
         num_header_pages + num_kernel_pages + num_ramdisk_pages
     )  # header + kernel + ramdisk
     image_info_list.append((second_offset, second_size, 'second'))
 
     if recovery_dtbo_size > 0:
-        dtbo_offset = page_size * (num_header_pages + num_kernel_pages +
-                                   num_ramdisk_pages + num_second_pages)
-        image_info_list.append((dtbo_offset, recovery_dtbo_size,
+        image_info_list.append((recovery_dtbo_offset, recovery_dtbo_size,
                                 'recovery_dtbo'))
 
     for image_info in image_info_list:
-- 
2.17.1

